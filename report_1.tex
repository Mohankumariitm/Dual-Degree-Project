\documentclass{article}
\usepackage{graphicx}
\usepackage{xcolor}
\usepackage{listings}
\usepackage{hyperref}
\definecolor{vgreen}{RGB}{104,180,104}
\definecolor{vblue}{RGB}{49,49,255}
\definecolor{vorange}{RGB}{255,143,102}

\lstdefinestyle{verilog-style}
{
    language=Verilog,
    basicstyle=\small\ttfamily,
    keywordstyle=\color{vblue},
    identifierstyle=\color{black},
    commentstyle=\color{vgreen},
    numbers=left,
    numberstyle=\tiny\color{black},
    numbersep=10pt,
    tabsize=8,
    literate=*{:}{:}1
}

\begin{document}

\title{ LUT optimization of Fast Fourier Transform }
\author{ Mohankumar Ramachandran }
\author{ EE14B095 }

\maketitle

\begin{abstract}
Fast Fourier Transform (FFT) remains of a great importance due to its substantial role in the field of signal processing and imagery. In this report, multiple designs of 8 point FFT  algorithm is proposed. The developed architecture was implemented using an FPGA . Though, the material resources of the FPGA are limited, particularly the integrated DSP blocks, different approaches are used during the Verilog description with the aim to reduce the necessary number of LUTs. The experimental validation was done using ISIM simulation tool, where the numerical synthesis and the post and route described in Verilog was realized using ISE Design Suite 14.7. The FFT modules of all the implementations were tested using a python script with various corner input test vectors.
\end{abstract}


\section{Cooley–Tukey algorithm }
\label{raw_Cooley_Tukey_algorithm}

\subsection{Overview}
Cooley–Tukey algorithm re-expresses the discrete Fourier transform (DFT) of an arbitrary composite size N = $N_1N_2$ in terms of $N_1$ smaller DFTs of sizes $N_2$, recursively, to reduce the computation time to \textbf{O}(N log N) for highly composite N.

\subsection{Calculation}
This is a direct implementation of Cooley-Turkey Algorithm without any modifications , and for a 8 point FFT , it involves 2 multiplications for a single output calculation. The equations involving the calculation of FFT in shown below. 
$\\\\
t_1=D(0) + D(4);  m_3=D(0) - D(4); \\
t_2=D(6) + D(2);  m_6=j*(D(6)-D(2)); \\
t_3=D(1) + D(5);  t_4=D(1) - D(5); \\
t_5=D(3) + D(7);  t_6=D(3) - D(7); \\ 
t_8=t_5 + t_3;  m_5=j*(t_5-t_3); \\
t_7=t_1 + t_2;  m_2=t_1 - t_2; \\
m_0=t_7 + t_8;  m_1=t_7 - t_8; \\
m_4=sin(\pi/4)*(t_4 - t_6);  m_7=-j* sin(\pi/4)*(t_4 + t_6); \\
s_1=m_3 + m_4;  s2=m_3 - m_4; \\
s_3=m_6 + m_7;  s4=m_6 - m_7; \\
DO(0)=m_0;  DO(4)=m_1; \\ 
DO(1)=s_1 + s_3;  DO(7)=s_1 - s_3; \\
DO(2)=m_2 + m_5;  DO(6)=m_2 - m_5; \\
DO(5)=s_2 + s_4;  DO(3)=s_2 - s_4; \\\\
$
where D and DO are input and output arrays of the complex data $t_1$,…,$t_8$, $m_1$,…,
$m_7$, $s_1$,…,$s_4$ are the intermediate complex results. As we see the algorithm contains only 2 multiplications to the untrivial coefficient sin($\pi$/4) = 0.7071, and 26 * 2 real additions and subtractions. The multiplication to a coefficient j means the negation the imaginary part and swapping real and imaginary parts.

\subsection{Implementation}

The below code implements the \hyperref[raw_Cooley_Tukey_algorithm]{Cooley–Tukey algorithm }. inp1,...inp8 are the 16 bit signed floating point inputs of Q format and out1-real , out1-imag, ...,out8-real,out8-imag are the real and imaginary outputs in 16 bit Q format of the FFT8 module.clk , rst are the clock , reset inputs respectively , and output-stb is the output strobe , which is enabled once the output is calculated.


\begin{lstlisting}[style={verilog-style}]
`timescale 1ns / 1ps

module fft8(
	input signed [15:0] inp1,
	input signed [15:0] inp2,
	input signed [15:0] inp3,
	input signed [15:0] inp4,
	input signed [15:0] inp5,
	input signed [15:0] inp6,
	input signed [15:0] inp7,
	input signed [15:0] inp8,
	input clk,
	input rst,
	output signed [15:0] out1_real,
	output signed [15:0] out1_imag,
	output signed [15:0] out2_real,
	output signed [15:0] out2_imag,
	output signed [15:0] out3_real,
	output signed [15:0] out3_imag,
	output signed [15:0] out4_real,
	output signed [15:0] out4_imag,
	output signed [15:0] out5_real,
	output signed [15:0] out5_imag,
	output signed [15:0] out6_real,
	output signed [15:0] out6_imag,
	output signed [15:0] out7_real,
	output signed [15:0] out7_imag,
	output signed [15:0] out8_real,
	output signed [15:0] out8_imag,
	output out_stb
);
	
	localparam signed sin_45 = 16'b00000000_10110101;
	localparam signed sin_315 = 16'b11111111_01001011;

	reg signed [31:0] t1_46,t2_46; 
	reg signed [15:0] t1,t2,t3,t4,t5,t6,t7,t8,m0,m1,m2,m3,m4,m5_imag,m6_imag,m7_imag,s1,s2,s3_imag,s4_imag;
	reg output_stb;
	
	initial 
		begin
			output_stb = 1'b0;
		end

	always @( posedge clk )
		begin
			if (rst == 1'b1)
				begin
					output_stb = 1'b0;
				end
			else
				begin
					t1 = inp1 + inp5;
					t2 = inp7 + inp3;
					t3 = inp2 + inp6;
					t5 = inp4 + inp8;
					m3 = inp1 - inp5;
					m6_imag = inp7 - inp3;
					t4 = inp2 - inp6;
					t6 = inp4 - inp8;
					t8 = t5 + t3;
					t7 = t1 + t2;
					m0 = t7 + t8;
					t1_46 = sin_45 * ( t4 - t6);
					m4 = t1_46 [23:8]; 
					m5_imag = t5 - t3;
					m2 = t1 - t2;
					m1 = t7 - t8;
					t2_46 = sin_315 * ( t4 + t6); 
					m7_imag = t2_46 [23:8];
					s1 = m3 + m4;
					s2 = m3 - m4;
					s3_imag = m6_imag + m7_imag;
					s4_imag = m6_imag - m7_imag;
					output_stb = 1'b1;
				end
		end
	assign out1_real = m0;
	assign out1_imag = 16'b0000000000000000;
	assign out2_real = s1;
	assign out2_imag = s3_imag;
	assign out3_real = m2;
	assign out3_imag = m5_imag;
	assign out4_real = s2;
	assign out4_imag = ~s4_imag + 1'b1;
	assign out5_real = m1;
	assign out5_imag = 16'b0000000000000000;
	assign out6_real = s2;
	assign out6_imag = s4_imag;
	assign out7_real = m2;
	assign out7_imag = ~m5_imag + 1'b1;
	assign out8_real = s1;
	assign out8_imag = ~s3_imag + 1'b1;
	assign out_stb = output_stb;
endmodule

\end{lstlisting}


\end{document}




